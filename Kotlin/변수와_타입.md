
# 코틀린에서의 변수
## var vs val
1. var는 가변, val은 불변 (Java에서의 final,  read-only)
2. val은 다시 값을 assign 할 수 없다.
3. 코틀린은 **타입을 추론**해주기 때문에 명시적으로 타입을 적어주지 않아도 된다.
	- 명시적으로 적어주고 싶으면 `var number: Long` 과 같은 식으로 선언
	- 초기값을 지정해주지 않는 경우에는 무조건 타입을 명시해줘야 함 ( 초기화 하지 않으면 `must be initialized` 에러)
4. val로 Collection을 선언해도 내부 element 추가, 삭제는 가능
5. **클린 코드 를 위한 팁** : 일단 val로 변수를 선언하고 수정이 필요한 경우에만 var로 바꾸는게 코드가 깔끔해짐

## Primitive Type
```java
long number1 = 10L;
Long number2 = 1_000L;
```
```kotlin
var number1 = 10L
var number2 = 1_000L
```

코틀린에서의 primitive type 과 reference type
- 코틀린은 숫자, 문자, 불리언 같은 몇몇 타입에 대해 연산시에는 알아서 Primitive Type으로 변환하여 연산해주어서 Boxing, Unboxing에 대한 오버헤드를 고려하지 않아도 된다.
- [[코틀린에서의 Wrapper Type]]

## nullable 변수 
Java에서 `Long` 과 같은 reference type은 null이 들어갈 수 있다.
코틀린은 nullable을 명시하기 위해 `타입?` 로 선언해주어야 한다.
```kotlin
var number: Long? = 1_000L
```

## 객체 인스턴스화
```java
Person person = new Person("Danny");
```
```kotlin
var person = Person("Danny")
```
코틀린은 인스턴스화 할 때 `new` 사용하지 않음


# 코틀린에서 null 다루기
## Kotlin에서 null 체크
```java
public boolean startWithA(String str){
	return str.startsWith("A");
}
```
위 자바 메소드는 null-safe 하지 않다. 만약 str이 null로 들어올 경우 NullPointerException이 발생한다.

위 로직을 자바에서 null-safe하게 구현하기 위해서는 아래와 같이 str이 null인지 아닌지 조건문으로 검사해줘야 한다.
```java
public boolean startsWithA(String str){
	if(str == null)
		return false;

	return str.startsWith("A");
}
```

그리고 위 자바 메소드를 코틀린으로 표현하면 아래와 같이 된다.
```kotlin
fun startsWithA(str: String?): Boolean {  
    if (str == null) {  
        return false  
    }  
  
    return str.startsWith("A")  
}
```

## Safe Call과 Elvis 연산자
### Safe Call
null이 아니면 뒤의 함수나 프로퍼티를 접근한다.
만약 null이라면 그대로 null이 된다.
따라서, nullable로 선언된 변수에 대해서는 `.` 으로 바로 접근할 수 없고 `?.` 로 접근해야 한다.
```kotlin
val str: String? = "ABC"
println(str.length) // 에러!
println(str?.length) // ABC 출력

val str: String? = null  
println(str?.length) // null 출력
```

### Elvis 연산자
Elvis 연산자는 `?:` 로 나타내고 앞의 연산 결과가 null 이면 뒤의 값을 사용하도록 한다.

```kotlin
val str: String? = null
println(str?.length ?: 0) // 0 출력
```

Safe Call과 Elvis 연산자를 사용해서 위 startWithA 메소드를 코틀린스럽게 다시 짜면 아래와 같이 된다.
```kotlin
fun startsWithA(str: String?): Boolean {
	return str?.startsWith("A") ?: false
}
```

## Not Null Assertion
nullable type 이지만, 아무리 생각해도 null이 될 수 없는 경우들이 있다.

```kotlin
fun startWithA(str: String?) : Boolean {
	return str!!.startWith("A")
}
```

위 코드처럼 컴파일러에게 str는 절대 null이 될 수 없다는 것을 미리 알려주어 Safe Call같은 null 체크 로직을  생략한다.
하지만, str에 null이 들어온다면 런타임에 NullPointerException이 발생한다.

개발하다가 null이 절대로 들어 오면 안되지만 들어오는 경우를 일부러 캐치하기 위해 사용 가능할 것 같다.

## 플랫폼 타입
코틀린에서 Java 코드를 가져다 쓸 때 어떤 타입이 null인지, 아닌지 어떻게 처리할까 ? 

만약 Java 코드에서 @Nullable, @NotNull 등과 같은 어노테이션이 붙어 있다면 (javax.annotion, org.jetbrains.annotation) 코틀린에서도 nullable 정보를 파악한다.
```java
import org.jetbrains.annotations.Nullable;  
  
public class Person {  
    private final String name;  
  
    public Person(String name) {  
        this.name = name;  
    }  
  
    @Nullable  
    public String getName() {  
        return name;  
    }  
}
```
```kotlin
fun main() {  
    val person = Person("Danny");  
    startWithA(person.name) // 위 클래스에서는 nullable이므로 컴파일 에러 발생
}  
  
fun startWithA(str: String): Boolean {  
    return str.startsWith("A")  
}
```

하지만, 어노테이션이 붙지 않아서 코틀린에서 null 정보를 알 수 없을 때를 플랫폼 타입이라고 한다.
플랫폼 타입으로 인해 Runtime에서 NPE가 발생할 수 있다.

# 코틀린에서의 Type
## 기본 타입
코틀린은 초기화된 값을 보고 타입을 추론해준다.
```kotlin 
val number1 = 3 // Int
val number2 = 3L // Long
val number3 = 3.0f // Float
val number4 = 3.0 // Double
```

## 타입 캐스팅
## Kotlin만의 3가지 타입
## String Interpolation, String Indexing
